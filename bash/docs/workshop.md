# Bash: От нуля до автоматизатора

## План воркшопа

## Блок 1: Окружение и I/O Redirection

### Подсказки для спикера

- **Визуальный контроль:** запусти `tail -f error.log` в маленьком отдельном окне, чтобы участники видели, как там появляются строки в реальном времени, когда ты совершаешь ошибки в основном окне.
- **Подвох:** Приготовь команду, которая точно выдаст ошибку (например, `ls /root` от обычного пользователя), чтобы продемонстрировать, что обычный `>` не ловит сообщения об ошибках.

### Текст для выступления

Добро пожаловать в мир, где всё - это поток данных. В Bash у каждой запущенной программы по умолчанию открыто три канала, мы называем их "файловыми дескрипторами

1. stdin (0) - Вход: то, что вы печатаете программе с клавиатуры.
2. stdout (1) - Выход: стандартные ответы программы, которые вы видите на экране.
3. stderr (2) - Ошибки, которые программа выплевывает, если что-то пошло не так.

Зачем нам это знать? ПОТОМУ ЧТО ЭТО - БАЗА. Вам нужно, чтобы отчеты ушли в один файл, а ошибки - в другой, чтобы утром вы могли быстро понять, что сломалось. Сегодня мы научимся быть диспетчерами этих потоков

### Живое демо

1. **Захват стандартного вывода (stdout)** Как сохранить результат команды в файл вместо экрана.

   ```bash
   # Вывод просто улетает в терминал
   echo "Hello, Bash World"

   # Вывод сохраняется в файл. Экран пуст!
   echo "Hello, Bash World" > greeting.txt

   # Проверяем содержимое
   cat greeting.txt
   ```

2. **Перезапись vs Дозапись** Важнейший момент, чтобы не стереть важные данные.

   ```bash
   # Один знак '>' стирает всё, что было в файле, и пишет заново
   echo "New line" > greeting.txt

   # Два знака '>>' добавляют строку в конец файла
   echo "Another line" >> greeting.txt
   ```

3. **Работа с ошибками (stderr)** Самый "просветляющий" момент для новичков.

   ```bash
   # Пытаемся заглянуть туда, где нам не рады.
   # Мы увидим ошибку на экране, хотя пытаемся её сохранить!
   ls /root > output.txt

   # Почему в output.txt пусто? Потому что 'Permission denied' - это stderr (2), а не stdout (1).
   # Ловим именно ошибку:
   ls /root 2> errors.log

   # А теперь магия: всё в разные корзины
   ls -la /home /root > success.log 2> failures.log
   ```

   По итогу создаётся 2 файла:

   ```bash
   # failures.log
   ls: невозможно открыть каталог '/root': Отказано в доступе
   ```

   ```bash
   # success.log
   /home:
   итого 12
   drwxr-xr-x  3 root   root   4096 окт 19 18:08 .
   drwxr-xr-x 23 root   root   4096 ноя 11 19:56 ..
   drwxr-x--- 34 chouqe chouqe 4096 фев  7 16:09 chouqe
   ```

4. Черная дыра `/dev/null` Иногда нам плевать на ошибки.

   ```bash
   # Удаляем поток ошибок в никуда
   ls /root 2> /dev/null
   ```

### Выводы

- `>` - перенаправить поток stdout (создать/перезаписать файл).
- `>>` - перенаправить поток stdout (дописать в конец).
- `2>` - перенаправить только поток ошибок (stderr).
- `&>` - направить и успех, и ошибки в один файл.
- `/dev/null` - это системный "шредер". Всё, что туда попадает, исчезает навсегда.

### Вопросы

- В: Что будет, если я напишу `команда > файл`, а папки для файла не существует?
  - О: Bash выдаст ошибку, так как он умеет создавать файлы, но не умеет автоматически создавать цепочки папок (для этого нужен `mkdir -p`).
- В: Можно ли направить вывод одной команды на вход другой?
  - О: Да, но это тема следующего блока про "Пайпы" (`|`). `>` работает только с файлами/устройствами.
- В: Как вывести текст и на экран, и в файл одновременно?
  - О: Для этого есть специальная команда `tee`, например: `echo "hi" | tee file.txt`.

## Блок 2: Wildcards (Маски) и Brace Expansion (Раскрытие скобок)

### Подсказки для спикера

- **Главный секрет:** Объясни, что маски (Wildcards) раскрывает **сам Bash**, а не команда (`ls` или `rm`). Команда даже не знает, что была звездочка - она получает уже готовый список файлов.
- **Предупреждение:** Будь осторожен с `rm *`. Покажи это на примере пустой папки.

### Текст для выступления

Представьте, что у вас в папке 10 000 фотографий, и вам нужно найти только те, что сделаны в формате `.png`, начинаются на слово `vacation` и имеют в названии одну любую цифру. Вы будете искать их глазами? Нет.

В Bash есть **Wildcards** (подстановочные знаки) - это джокеры, которые заменяют части имен файлов. А еще есть **Brace Expansion** - это суперсила, которая позволяет генерировать строки, списки и целые структуры папок одной короткой командой. Это экономит тысячи нажатий на клавиши".

### Живое демо

1. **Звезда вечера - `*`** Самый популярный джокер. Означает "любое количество любых символов" (даже ноль).

   ```bash
   # Переходим в рабочую папку
   cd ~/workshop/data

   # Создаём файлы
   touch file1.txt file2.txt file3.txt file4.log file5.log report.log

   # Показать все файлы, заканчивающиеся на .txt
   ls *.txt

   # Показать всё, что начинается на 'report'
   ls report*

   # Удалить всё (не делайте этого в корне!)
   rm *
   ```

2. **Точечный удар - `?` и `[]`**

   Когда нужна точность.

   ```bash
   # Найти файлы типа file1.log, file2.log (строго один символ на месте ?)
   ls file?.log

   # Диапазоны: найти файлы, где в конце цифра от 1 до 5
   ls file[1-5].txt

   # Исключение: всё, кроме файлов на букву 'a'
   ls [!a]*
   ```

3. **Генератор списков `{}` (Brace Expansion)** Это не поиск по существующим файлам, это создание строк из воздуха.

   ```bash
   # Создать сразу 3 папки: dev, stage, prod
   mkdir {dev,stage,prod}

   # Создать последовательность (диапазон)
   touch backup_{1..10}.sql

   # Комбинация: создаем структуру проекта за 1 секунду
   mkdir -p project/{src,bin,lib,docs/txt}
   ```

4. **Совмещение магии**

   ```bash
   # Посмотреть содержимое всех папок проекта одним махом
   ls -R project/
   ```

### Выводы

- `*` - Любое количество символов.
- `?` - Ровно один символ.
- `[seq]` - Любой символ из перечисленных (например, `[0-9]` или `[atp]`).
- `{a,b,c}` - Развернуть список слов.
- `{1..10}` - Сгенерировать последовательность чисел или букв.

**Важно:** Сначала Bash раскрывает `{}` и `*`, и только потом передает результат команде.

### Вопросы

- В: В чем разница между `ls *.txt` и `ls "*.txt"`?
  - О: Огромная! В первом случае Bash найдет файлы и отдаст их `ls`. Во втором - он передаст строку со звездочкой команде `ls` буквально, и та будет искать файл с именем "звездочка точка ти-икс-ти" (и, скорее всего, не найдет).
- В: Можно ли вложить скобки в скобки?
  - О: Да! `mkdir -p v{1,2}/{test,data}` создаст `v1/test`, `v1/data`, `v2/test`, `v2/data`.
- В: Работает ли `*` с вложенными папками?
  - О: Обычно `*` не заходит в подпапки. Для этого используется `**` (если включена опция `globstar`) или команда `find`.

## Блок 3: Переменные и Command Substitution (Подстановка команд)

### Подсказки для спикера

- **Синтаксическая ловушка:** Акцентируй внимание на том, что вокруг знака `=` нельзя ставить пробелы. Это самая "бесячая" ошибка для новичков. `NAME = "Alex"` - это ошибка, `NAME="Alex"` - это переменная.
- **Кавычки - это важно:** Покажи наглядную разницу между `" "` и `' '`. Это база безопасности и корректности скриптов.
- **Лайфхак:** Покажи команду `env`, чтобы участники увидели, что в системе уже живут сотни переменных (вроде `PATH` или `USER`).

### Текст для выступления

Переменные тут есть, как и в других языках программирования. Но что если нам нужно записать не просто текст, а результат работы другой программы? Например, текущую дату или имя пользователя? Для этого существует **Command Substitution**.
Мы заставляем одну команду выполнить работу, ловим её ответ и сохраняем его в переменную. Это позволяет нам создавать динамические скрипты, которые адаптируются к ситуации.

### Живое демо

1. **Создание и вызов переменной**

   ```bash
   # Присваиваем значение (без пробелов!)
   USER_ROLE="Student"

   # Обращаемся к переменной через знак $
   echo $USER_ROLE

   # Чтобы приклеить текст к переменной, используем фигурные скобки
   echo "You are the best ${USER_ROLE}s in this room!"
   ```

2. **Command Substitution (Магия `$()`)**

   ```bash
   # Сохраняем результат команды date в переменную
   CURRENT_DATE=$(date +%Y-%m-%d)

   # Сохраняем количество файлов в текущей директории
   FILE_COUNT=$(ls | wc -l)

   echo "Today is $CURRENT_DATE, and we have $FILE_COUNT files here."
   ```

3. **Битва кавычек: Одинарные vs Двойные**

   ```bash
   PRICE=100

   # Двойные кавычки: Bash "заглядывает" внутрь и видит переменную
   echo "The price is: $PRICE"

   # Одинарные кавычки: Bash видит просто текст (Literal string)
   echo 'The price is: $PRICE'
   ```

4. **Переменные окружения (Environment Variables)**

   ```bash
   # Посмотрим, кто мы в этой системе
   echo "I am user $USER, and my shell is $SHELL"
   ```

### Выводы

- `VAR=value` - создаем переменную. Без пробелов вокруг `=`.
- `$VAR` - извлекаем значение.
- `$(command)` - современный способ выполнить команду и подставить её вывод (заменяет старые обратные кавычки `command`).
- `" "` (двойные кавычки) - разрешают интерпретацию `$`.
- `' '` (одинарные кавычки) - запрещают всё, выводят текст "как есть".

### Вопросы

- В: Нужно ли всегда ставить фигурные скобки вокруг переменной, типа `${VAR}`?
  - О: Не обязательно, но это хорошая привычка. Это спасает, если вам нужно написать `echo "${VAR}_backup"`. Без скобок Bash будет искать переменную `VAR_backup`, которой не существует.
- В: Можно ли вложить одну подстановку в другую?
  - О: Да! Например: `DIR_NAME=$(echo "backup_$(date +%F)")`. Это работает отлично.
- В: Как удалить переменную?
  - О: Командой unset `VAR_NAME`.

## Блок 4: Конвейеры (Pipes) и фильтрация: Grep & Regex

### Подсказки для спикера

- **Визуализация:** Представь пайп (`|`) как физическую трубу. Данные вылетают из "выхода" одной программы и попадают прямо во "вход" другой.
- **Главная фишка:** Обрати внимание, что `grep` работает построчно. Он выплевывает всю строку, если в ней нашлось совпадение.
- **Лайфхак:** Покажи флаг `--color=auto` (обычно он включен по умолчанию, но полезно знать), чтобы видеть, что именно совпало в тексте.

### Текст для выступления

В предыдущих блоках мы научились сохранять данные в файлы. Но что если нам не нужно сохранять промежуточный результат? Что если мы хотим взять огромный лог, выкинуть из него всё лишнее, оставить только ошибки и сразу их посчитать?
Для этого есть **Pipes (Конвейеры)**. Символ вертикальной черты ё - это клей, который соединяет программы. Мы строим конвейер, где на входе - сырые данные, а на выходе - готовый ответ. А фильтровать этот поток мы будем с помощью `grep` и **регулярных выражений** - языка описания текстовых шаблонов".

### Живое демо

1. **Основы Pipes** Связываем две команды.

   ```bash
   # Берем список всех файлов в /etc и считаем количество строк
   ls /etc | wc -l

   # Берем вывод env и сортируем его по алфавиту
   env | sort
   ```

2. **Grep** - поиск иголки в стоге сена

   ```bash
   # Найти пользователя root в базе пользователей
   cat /etc/passwd | grep "root"

   # Поиск без учета регистра (флаг -i)
   echo "ERROR: something broke" | grep -i "error"

   # Режим "анти-поиск" (флаг -v): показать всё, КРОМЕ строк с "nologin"
   cat /etc/passwd | grep -v "nologin"
   ```

3. **Введение в Регулярные выражения (Regex)** Используем флаг `-E` (Extended Regex) для магии шаблонов.

   ```bash
   # Найти строки, которые НАЧИНАЮТСЯ с "bin" (символ ^)
   grep -E "^bin" /etc/passwd

   # Найти строки, которые ЗАКАНЧИВАЮТСЯ на "bash" (символ $)
   grep -E "bash$" /etc/passwd

   # Найти строки, где есть цифры от 0 до 9
   echo "User123" | grep -E "[0-9]+"
   ```

4. **Построение цепочки (Pipeline)**

   ```bash
   # Найти все запущенные процессы ssh, убрать из вывода сам grep и посчитать количество
   ps aux | grep "ssh" | grep -v "grep" | wc -l
   ```

### Выводы

- `|` **(Pipe)** - передает вывод левой команды на вход правой.
- `grep` - ищет строки по шаблону.
- `^` - начало строки, `$` - конец строки.
- `-v` - инверсия (показать то, что НЕ совпало).
- Цепочки могут быть любой длины - это и есть настоящая автоматизация.

### Вопросы

- В: Чем `grep` отличается от поиска через `Ctrl+F`?
  - О: `grep` можно встроить в автоматический процесс. Он может обрабатывать гигабайты текста быстрее любого редактора и возвращать только нужные куски.
- В: Что если я хочу искать точку `.`? Ведь в Regex точка - это "любой символ".
  - О: Её нужно "экранировать" обратным слэшем: `grep "\."`.
- В: Можно ли пайпом передать файл?
  - О: Нет, пайп передает вывод команды. Чтобы передать файл на вход, используйте `cat file | command` или перенаправление ввода `command < file`.

## Блок 5: Потоковый редактор Sed (Stream Editor)

### Подсказки для спикера

- Безопасность прежде всего: Всегда сначала показывай работу `sed` без флага `-i`. Объясни, что по умолчанию `sed` - это "симулятор": он показывает, что было бы, если бы мы применили изменения.
- Разделители: Если в тексте много слешей (например, меняем пути `/var/www`), скажи, что в `sed` можно использовать любой символ как разделитель, например: `sed 's|/var/www|/opt/app|'`. Это взорвет им мозг своей простотой.

### Текст для выступления

Представьте ситуацию: у вас есть конфигурационный файл на 1000 строк, и вам нужно заменить во всём файле слово `localhost` на `db.server.com`. Открывать его в `nano` или `vim` и искать каждое вхождение вручную - это путь к ошибкам.

**Sed** - это потоковый редактор. Он не открывает файл в привычном смысле. Он прогоняет текст через себя, применяет к нему ваши правила и выдает результат. Он умеет заменять, удалять, вставлять и трансформировать текст со скоростью света. Это ваш основной инструмент для автоматической правки конфигов

### Живое демо

1. **Базовая замена (Substitute)** Самая частая команда: `s`.

   ```bash
   # Создадим тестовый файл
   echo "The port is 8080" > config.txt

   # Заменим 8080 на 9090 (только в выводе на экран!)
   sed 's/8080/9090/' config.txt

   # Проверяем файл - он НЕ изменился. Sed по умолчанию осторожен.
   cat config.txt
   ```

2. **Флаг Global (`g`) и сохранение (`-i`)**

   ```bash
   # По умолчанию sed меняет только ПЕРВОЕ совпадение в строке.
   # Чтобы поменять все, нужен флаг 'g' (global)
   echo "apple apple" | sed 's/apple/orange/g'

   # Чтобы РЕАЛЬНО изменить файл, используем флаг -i (in-place)
   sed -i 's/8080/9090/g' config.txt
   ```

3. **Удаление строк**

   ```bash
   # Удалить все строки, содержащие слово "DEBUG"
   # Команда 'd' (delete)
   sed '/DEBUG/d' app.log

   # Удалить все закомментированные строки (начинающиеся на #)
   sed '/^#/d' config.txt
   ```

4. **Сложные замены (Regex в Sed)**

   ```bash
   # Заменить все цифры на знак X
   echo "My pass is 12345" | sed -E 's/[0-9]/X/g'
   ```

### Выводы

- `sed 's/old/new/g'` - стандартная формула замены.
- **Флаг** `-i` - вносит изменения прямо в файл (будьте с ним осторожны!).
- Команда `d` - удаляет строки по шаблону.
- **Regex** - `sed` отлично дружит с регулярными выражениями (используйте `-E`).

### Вопросы

- В: Можно ли сделать бэкап файла перед тем, как `sed -i` его изменит?
  - О: Да! Если написать `sed -i.bak 's/a/b/' file`, то создастся копия `file.bak`. Это лучший способ подстраховаться.
- В: Как заменить текст только на конкретной строке (например, на пятой)?
  - О: Укажите номер перед командой: `sed '5s/old/new/' file`.
- В: Что если в искомом тексте есть слеш `/`?
  - О: Его нужно либо экранировать `\/`, либо сменить разделитель в `sed`, например на `sed 's#old#new#'`.

## Блок 6: Мощный парсинг: AWK

### Подсказки для спикера

- Главная концепция: Объясни, что `awk` автоматически делит каждую строку на "поля" (столбцы) по пробелам или табуляции.
- **Магия $:** Покажи, что `$1` , `$2`, `$3`- это номера столбцов, а `$0` - это вся строка целиком.
- Лайфхак: Покажи переменную `NF` (Number of Fields) - это количество колонок. Она бесценна, когда нужно вытащить последнее слово в строке, даже если их там 10 или 20 (`$NF`).

### Текст для выступления

Представьте, что перед вами огромная таблица: вывод списка процессов, список пользователей или отчет о свободном месте на диске. Вам не нужны все данные, вам нужны только вторая и пятая колонки.

**AWK** - это не просто команда, это целый язык программирования, рожденный для работы с табличным текстом. Он позволяет фильтровать данные не просто по словам, а по логическим условиям: "покажи мне строки, где в третьей колонке число больше 100". Это ваш основной инструмент для генерации отчетов прямо из консоли

### Живое демо

1. **Печать конкретных колонок** Разберем вывод команды `df -h` (информация о дисках).

   ```bash
   # Вывести всё
   df -h

   # Вывести только название диска ($1) и процент использования ($5)
   df -h | awk '{print $1, $5}'

   # Добавим свой текст для наглядности
   df -h | awk '{print "Диск: " $1 " заполнен на: " $5}'
   ```

2. **Изменение разделителя (флаг `-F`)** По умолчанию `awk` ищет пробелы. Но что если нам нужно распарсить `/etc/passwd`, где данные через двоеточие?

   ```bash
   # Вывести только имена пользователей из системного файла
   awk -F ":" '{print $1}' /etc/passwd

   # -F -опция `awk` для указания разделителя полей
   # ":"- символ разделителя (в данном случае - двоеточие)
   ```

3. **Условия (Фильтрация данных)** `awk` умеет в математику и сравнения.

   ```bash
   # Вывести только те файловые системы, которые заполнены более чем на 10%
   # Мы используем substr или просто полагаемся на то, что awk отбросит знак % при сравнении
   df -h | awk '$5+0 > 10 {print $1, $5}'
   ```

4. **Начало и Конец (BEGIN и END)**

   ```bash
   # Посчитать общее количество строк в файле (имитация wc -l)
   ls -l | awk 'BEGIN {count=0} {count++} END {print "Всего файлов: " count}'

   # BEGIN {count=0}                     # Выполняется ДО обработки строк
   # {count++}                           # Выполняется ДЛЯ КАЖДОЙ строки
   # END {print "Всего файлов: " count}  # Выполняется ПОСЛЕ всех строк
   ```

### Выводы

- `$1, $2, ...` - обращение к конкретным столбцам.
- `$0` - вся строка.
- `-F` - задает разделитель (например, `-F ","` для CSV).
- `{print ...}` - основное действие.
- Условия пишутся перед фигурными скобками: `awk '$3 > 100 {print $1}'`.

### Вопросы

- В: Может ли `awk` заменить `grep`?
  - О: Да! `awk '/pattern/ {print}'` делает то же самое, что и `grep`. Но `awk` мощнее, так как может искать паттерн только в конкретном столбце: `awk '$2 ~ /admin/ {print $1}'`.
- В: Как вывести последнюю колонку, если я не знаю её номера?
  - О: Используйте переменную `$NF`.
- В: Тяжело ли `awk` обрабатывать большие файлы?
  - О: Напротив, он спроектирован для этого. Он читает файл построчно, поэтому потребляет минимум оперативной памяти даже на гигабайтных логах.

## Блок 7: Арифметика и условия: If / Else

### Подсказки для спикера

- **Синтаксический ад:** Сделай акцент на пробелах внутри скобок `[[$a == $b]]`. Это самая частая причина поломки скриптов у новичков. Bash воспринимает `[[` как команду, а всё остальное - как её аргументы. Без пробелов он их "не видит".
- Двойные скобки: Рекомендуй использовать современные двойные скобки `[[ ]]` для строк и файлов, и `(( ))` для математики. Это избавляет от многих проблем со спецсимволами.
- **Лайфхак:** Покажи, как быстро проверить код возврата предыдущей команды через переменную `$?`.

### Текст для выступления

До этого момента наши команды выполнялись слепо - одна за другой. Но настоящий интеллект появляется там, где есть выбор.

Инструкция **If/Else** позволяет вашему скрипту анализировать ситуацию. Хватает ли места на диске? Существует ли файл конфигурации? Является ли пользователь администратором?

### Живое демо

1. **Проверка файлов (Flags)** Самый полезный кейс в администрировании.

   ```bash
   # Проверяем, существует ли файл
   FILE="test.txt"

   if [[ -f "$FILE" ]]; then
       echo "Файл $FILE на месте."
   else
       echo "Файл $FILE потерялся, создаю новый..."
       touch "$FILE"
   fi
   ```

2. **Сравнение строк и чисел**

   ```bash
   NAME="chouqe"

   if [[ $NAME == "chouqe" ]]; then
       echo "Доступ разрешен."
   fi

   # Проверка: пустая ли переменная? (-z)
   if [[ -z "$SECRET_KEY" ]]; then
       echo "Ошибка: SECRET_KEY не задан!"
   fi
   ```

3. **Математика в Bash** `(( ))` Bash не очень любит дроби, но отлично справляется с целыми числами.

   ```bash
   AGE=20

   # Внутри (( )) можно использовать привычные > < ==
   if (( $AGE >= 18 )); then
       echo "Вход разрешен."
   fi

   # Простой инкремент (увеличение на 1)
   (( AGE++ ))
   echo "Через год вам будет $AGE"
   ```

4. Логические связки (И / ИЛИ)

   ```bash
   # Проверяем два условия сразу
   if [[ -d "logs" && -f "logs/app.log" ]]; then
       echo "Папка есть и лог внутри."
   fi
   ```

### Выводы

- `[[ ... ]]` - стандарт для проверок строк и файлов.
- `(( ... ))` - стандарт для математики и сравнения чисел.
- `-f` (файл), `-d` (директория), `-z` (пустая строка) - самые важные флаги.
- Пробелы внутри скобок обязательны!
- `if`, `then`, `else`, `fi` - четыре столпа конструкции.

### Вопросы

- В: В чем разница между `[` и `[[`?
  - О: `[` - это старый стандарт (команда test), она капризна к кавычкам. `[[` - это встроенная конструкция Bash, она мощнее, понимает Regex и прощает отсутствие кавычек в ряде случаев.
- В: Как проверить, успешно ли выполнилась предыдущая команда, не используя `if`?
  - О: Через "быстрые условия": `команда && echo` "Успех" или `команда || echo "Провал"`.
- В: Работает ли Bash с дробными числами (например, 3.14)?
  - О: Нативно - нет. Для этого обычно используют утилиту `bc` или `awk`.

## Блок 8: Циклы (For и While)

### Подсказки для спикера

- Бесконечный цикл: Покажи, как сделать бесконечный цикл `while true`, но сразу научи его прерывать (`Ctrl+C`).
- Разделитель имен: Предупреди, что `for` по умолчанию разделяет элементы по пробелам. Если в именах файлов есть пробелы, это может вызвать проблемы (но на воркшопе покажи стандартный путь).

### Текст для выступления

Представьте, что вам нужно переименовать 500 фотографий или проверить статус 10 разных серверов. Вы не будете копировать команду 500 раз. Для этого существуют циклы.

Цикл **For** берет список (например, все файлы в папке) и выполняет команду для каждого элемента. Цикл **While** работает иначе: он делает что-то "до тех пор, пока" условие верно. Сегодня мы научимся превращать одну команду в мощный конвейер, который обработает тысячи объектов за секунды

### Живое демо

1. **Простой цикл `for` с диапазоном**

   ```bash
   # Выведем цифры от 1 до 5
   for i in {1..5}; do
       echo "Итерация номер $i"
   done
   ```

2. **Итерация по файлам (самый частый кейс)**

   ```bash
   # Создадим несколько файлов для теста
   touch user_{1..3}.txt

   # Массовое переименование: добавим префикс 'old_'
   for file in *.txt; do
       mv "$file" "old_$file"
       echo "Файл $file переименован"
   done
   ```

3. **Цикл `while` - ожидание события** Имитируем мониторинг: проверяем, появился ли файл.

   ```bash
   # Скрипт будет ждать, пока не появится файл 'ready.txt'
   echo "Жду файл ready.txt..."
   while [[ ! -f "ready.txt" ]]; do
       echo -n "."
       sleep 1  # Ждем секунду, чтобы не грузить процессор
   done
   echo "Файл найден! Продолжаем работу."
   ```

4. **Построчное чтение файла через `while`**

   ```bash
   # Создадим список серверов
   echo -e "google.com\n8.8.8.8" > servers.txt

   # Читаем файл строку за строкой
   while read line; do
       echo "Пингую: $line"
       ping -c 1 "$line" | grep "received"
   done < servers.txt

   # ping -c 1 - это команда ping с ограничением количества отправляемых пакетов.
   ```

### Выводы

- `for` - используем, когда есть четкий список (файлы, массивы).
- `while` - используем для условий (пока файл не создан, пока юзер не ввел 'exit').
- `do ... done` - это границы тела цикла.
- `read` в связке с `while` - лучший способ обработать текстовый файл построчно.

### Вопросы

- В: Что будет, если запустить `for` в пустой папке?
  - О: По умолчанию Bash может передать саму маску `*.txt` как текст. Чтобы этого избежать, используют настройки `shopt -s nullglob`.
- В: Как выйти из цикла раньше времени?
  - О: Командой `break` (полный выход) или `continue` (переход к следующему кругу).
- В: Можно ли делать вложенные циклы?
  - О: Да, например, перебирать папки, а внутри них - файлы.

## Блок 9: Позиционные параметры и `$@`

### Подсказки для спикера

- **Счёт от нуля:** Обязательно объясни, что `$0` - это не первый аргумент, а имя самого файла. Это важно для вывода подсказок по использованию (Usage).
- **Кавычки вокруг `$@`:** Это критический момент. Всегда показывай аргументы в двойных кавычках `"$@"`. Если этого не сделать, аргументы с пробелами внутри (например, `"My Folder"`) развалятся на два разных слова.

### Текст для выступления

Когда вы пишете `mkdir my_folder`, команда `mkdir` знает, как назвать папку? Она берет это имя из **позиционных параметров.**

Когда мы запускаем скрипт и дописываем что-то после его имени, Bash автоматически нумерует эти слова. Первое слово попадает в переменную `$1`, второе в `$2` и так далее. А если мы хотим обрушить на скрипт целый список файлов, нам поможет символ-супергерой - `$@`. Сегодня мы сделаем наши скрипты гибкими, чтобы не переписывать код каждый раз, когда меняются входные данные

### Живое демо

1. **Основы нумерации** Создадим скрипт `hello.sh`:

   ```bash
   #!/bin/bash
   echo "Имя скрипта: $0"
   echo "Первый аргумент: $1"
   echo "Второй аргумент: $2"
   echo "Всего аргументов передано: $#"
   ```

   _Запуск_: `bash hello.sh Apple Orange`

2. **Использование аргументов в логике** Сделаем скрипт-калькулятор `add.sh`:

   ```bash
   #!/bin/bash
   # Простая проверка: передано ли 2 аргумента?
   if [[ $# -ne 2 ]]; then
       echo "Использование: $0 число1 число2"
       exit 1
   fi

   result=$(( $1 + $2 ))
   echo "Результат: $result"
   ```

3. **Массовая обработка через** `$@` Символ `$@` означает "все аргументы по очереди".

   ```bash
   # Скрипт 'check_files.sh'
   for item in "$@"; do
       if [[ -e "$item" ]]; then
           echo "[+] $item существует"
       else
           echo "[-] $item не найден"
       fi
   done
   ```

   _Запуск_: `bash check_files.sh file.txt config.json notes.doc`

4. **Сдвиг аргументов (Shift)** Иногда нужно забрать первый аргумент (например, команду `install` или `delete`), а остальные обработать циклом.

   ```bash
   COMMAND=$1
   shift # Выбрасывает старый $1, теперь $2 становится $1
   echo "Выполняю команду $COMMAND для файлов: $@"
   ```

### Выводы

- `$0` - путь/имя скрипта.
- `$1, $2...$9` - конкретные аргументы.
- `$#` - количество переданных аргументов (полезно для проверок `if`).
- `$@` - все аргументы сразу в виде списка (используйте в кавычках `"$@"`).
- `exit 1` - хороший тон, чтобы остановить скрипт, если аргументы неверны.

### Вопросы

- В: Что если мне нужно передать 15 аргументов? Как обратиться к 15-му?
  - О: После десятого аргумента нужно использовать фигурные скобки: `${15}`. Иначе Bash подумает, что это `$1` и приписанная рядом пятерка.
- В: В чем разница между `$@` и `$*`?
  - О: В кавычках: `"$@"` сохраняет каждый аргумент отдельно (даже с пробелами), а `"$*"` превращает всё в одну длинную строку. Почти всегда используйте `"$@"`.
- В: Как передать в аргумент строку с пробелом?
  - О: Просто оберните её в кавычки при запуске: `bash script.sh "New York"`.

## Блок 10: Функции и Scope (Область видимости)

### Подсказки для спикера

- **Функции - это мини-скрипты:** Объясните, что внутри функции работают те же правила, что и в основном скрипте (свои `$1`, `$2`), но они относятся только к функции.
- **Ловушка Global:** По умолчанию все переменные в Bash - глобальные. Это опасно! Обязательно покажите ключевое слово `local`, иначе функция может случайно испортить переменную в основной части программы.
- **Порядок важен:** В Bash нельзя вызвать функцию до того, как она была объявлена в коде. Сначала описание - потом вызов.

### Текст для выступления

Представьте, что в вашем скрипте нужно 10 раз проверить статус сервера. Вы же не будете дублировать код по несколько раз.

Функции позволяют нам дать группе команд имя. Теперь, вместо того чтобы писать сложную логику, вы просто вызываете это имя. Кроме того, мы разберем **Scope** - границы, внутри которых живут переменные. Мы научимся создавать "изолированные" переменные внутри функций, чтобы они не мешали основной работе скрипта. Это превращает "спагетти-код" в четкую структуру

### Живое демо

1. **Создание простой функции**

   ```bash
   # Описываем функцию
   say_hello() {
       echo "Привет! Я функция."
   }

   # Вызываем функцию (просто по имени, без скобок!)
   say_hello
   ```

2. **Аргументы внутри функции** Функция получает свои аргументы через `$1`, `$2`, даже если у самого скрипта они другие

   ```bash
   log_msg() {
       # $1 здесь - это ПЕРВЫЙ аргумент, переданный ФУНКЦИИ
       echo "[$(date +%T)] BLOCK-10: $1"
   }

   log_msg "Начинаем установку..."
   log_msg "Все прошло успешно!"
   ```

3. **Опасность Scope и слово `local`**

   ```bash
   NAME="Глобальный"

   change_name() {
       local NAME="Локальный" # Без local мы бы стерли глобальную переменную!
       echo "Внутри функции: $NAME"
   }

   change_name
   echo "Снаружи функции: $NAME"
   ```

4. **Возврат значений (Return Codes)** Функции в Bash не возвращают текст через `return`, они возвращают статус выхода (0-255).

   ```bash
   is_root() {
       if [[ $EUID -eq 0 ]]; then
           return 0 # Успех
       else
           return 1 # Провал
       fi
   }

   if is_root; then
       echo "Привет, Админ!"
   else
       echo "Ошибка: нужны права суперпользователя."
   fi
   ```

### Выводы

- `имя_функции() { ... }` - стандарт объявления.
- Вызов происходит просто по имени: `say_hello`.
- `local` - обязательно используйте внутри функций для всех внутренних переменных.
- `$1, $2, ...` - внутри функции это её собственные аргументы, а не аргументы скрипта.
- `return` - возвращает цифровой статус (0 = успех), а не данные. Для возврата текста используйте `echo` и подстановку `$(func)`.

### Вопросы

- В: Можно ли вынести функции в отдельный файл, чтобы не забивать основной скрипт?
  - О: Да! Это называется Sourcing. Вы пишете `source ./my_functions.sh` в начале скрипта, и все функции оттуда становятся доступны.
- В: Что будет, если я назову функцию именем существующей команды (например, `ls`)?
  - О: Функция будет иметь приоритет. Чтобы вызвать оригинальный `ls`, придется писать command `ls`.
- В: Можно ли передать массив в функцию?
  - О: Напрямую - сложно. Обычно передают элементы массива через `$@`.

## Блок 11: Обработка сигналов и команда Trap

### Подсказки для спикера

- **Демонстрация хаоса:** Сначала запусти скрипт, который создает кучу временных файлов и "зависает" (`sleep 100`). Нажми `Ctrl+C` и покажи, что мусор остался. Это лучшая мотивация для изучения `trap`.
- **Типы сигналов:** Не грузи участников всеми 64 сигналами. Достаточно трех: `SIGINT` (Ctrl+C), `SIGTERM` (вежливое завершение) и `EXIT` (любое завершение скрипта).
- **Специфика:** Объясни, что `trap` - это "предохранитель", который срабатывает автоматически.

### Текст для выступления

Представьте: ваш скрипт создал временную базу данных, скачал гигабайт логов и начал их обрабатывать. В этот момент пользователь случайно нажимает `Ctrl+C`. Что происходит? Скрипт просто "умирает", оставляя после себя горы мусора и заблокированные файлы.

Команда `trap` (ловушка) позволяет скрипту перехватить сигнал завершения

### Живое демо

1. **Ловушка на выход (EXIT)** Самый простой и надежный способ - `EXIT` срабатывает всегда, когда скрипт заканчивает работу (сам или по ошибке).

   ```bash
   #!/bin/bash

   # Устанавливаем ловушку: выполнить echo при выходе
   trap "echo 'Скрипт завершен, убираю за собой!'" EXIT

   echo "Работаем..."
   sleep 2
   # Скрипт заканчивается здесь, и сработает trap
   ```

2. **Перехват Ctrl+C (SIGINT)**

   ```bash
   #!/bin/bash

   # Создаем временный файл
   TEMP_FILE="/tmp/workshop_data.tmp"
   touch $TEMP_FILE

   # Ловушка для Ctrl+C
   trap "echo -e '\nПрервано пользователем! Удаляю $TEMP_FILE'; rm -f $TEMP_FILE; exit" SIGINT

   echo "Идет долгий процесс... Нажмите Ctrl+C, чтобы проверить ловушку."
   while true; do
       sleep 1
   done
   ```

3. **Очистка временных папок (Best Practice)** Покажи, как упаковать очистку в функцию и привязать её к `trap`.

   ```bash
   cleanup() {
       echo "Очистка временных ресурсов..."
       rm -rf /tmp/test_dir
   }

   trap cleanup EXIT SIGINT SIGTERM
   mkdir /tmp/test_dir
   # ... код скрипта ...
   ```

### Выводы

- `trap 'команда' СИГНАЛ` - основной синтаксис.
- `SIGINT` (2) - это сигнал от Ctrl+C.
- `EXIT` - псевдо-сигнал, который срабатывает при любом завершении скрипта (даже успешном).
- Если внутри `trap` для `SIGINT` не написать `exit`, скрипт может продолжить работу после выполнения команды ловушки (иногда это полезно, но чаще - нет).

### Вопросы

- В: Можно ли перехватить сигнал `kill -9`?
  - О: Нет. `SIGKILL` (9) - это "расстрел без суда". Операционная система убивает процесс мгновенно, не давая ему шанса выполнить даже `trap`.
- В: Можно ли поставить несколько ловушек?
  - О: Да, но последняя команда `trap` для конкретного сигнала перезапишет предыдущую.
- В: Как отключить ловушку в середине скрипта?
  - О: Вызвать `trap - SIGINT` (черточка сбрасывает поведение к стандартному).

## Блок 12: Exit Codes (Коды завершения) и отладка (Debugging)

### Подсказки для спикера

- Переменная `$?`: Это главный герой блока. Покажите, как она меняется после каждой команды.
- Режим "Рентгена": Покажите флаг `-x`. Это превращает "черный ящик" скрипта в прозрачный процесс, где видна каждая подстановка переменной.
- Философия: Объясните, что `0` - это "всё хорошо" (единственный код успеха), а любое число от `1` до `255` - это "что-то пошло не так".

### Текст для выступления

Как компьютер понимает, что ваша команда выполнилась успешно? Он не читает текст на экране. Он смотрит на **Exit Code** - невидимое число, которое оставляет после себя любая программа. Если это `0`, мы идем дальше. Если нет - нужно бить тревогу.

### Живое демо

1. Проверка `$?` (Магия числа ноль)

   ```bash
   # Успешная команда
   ls /etc > /dev/null
   echo "Статус успеха: $?"

   # Команда с ошибкой
   ls /non_existent_folder 2> /dev/null
   echo "Статус провала: $?"
   ```

2. Свой код выхода в скрипте Создадим скрипт `db_check.sh`:

   ```bash
   #!/bin/bash
   DB_STATUS="offline"

   if [[ "$DB_STATUS" == "offline" ]]; then
       echo "Ошибка: База данных недоступна!"
       exit 1  # Мы сами сообщаем системе, что произошел сбой
   fi

   exit 0 # Всё отлично
   ```

3. Автоматическая остановка (`set -e`) Покажите, как заставить скрипт "самоуничтожаться" при первой же ошибке, чтобы она не вызвала лавину проблем.

   ```bash
   #!/bin/bash
   set -e  # Прекратить работу при любой ошибке

   cd /missing_folder  # Скрипт упадет здесь
   echo "Эта строка никогда не напечатается"
   ```

4. Режим отладки (set -x) Самый полезный инструмент.

   ```bash
   #!/bin/bash
   set -x  # Включает вывод каждой команды перед исполнением

   USER="admin"
   TARGET="/var/log/app"

   mkdir -p $TARGET
   cp sample.log "$TARGET/${USER}_data.log"
   ```

### Выводы

`$?` - содержит код возврата последней выполненной команды.
`0` = Успех. `1-255` = Ошибка.
`exit N` - способ завершить скрипт с нужным кодом.
`set -e` - режим "безопасности" (стоп при любой ошибке).
`set -x` - режим "отладки" (показ хода выполнения).

### Вопросы

- В: Что будет, если в скрипте не написать `exit` в конце?
  - О: Скрипт вернет код последней выполненной в нем команды.
- В: Как проверить код выхода, если я использую пайп (`command1` | `command2`)?
  - О: `$?` покажет только код последней команды (`command2`). Для проверки всей цепочки используется массив `${PIPESTATUS[@]}`.
- В: Можно ли использовать свои коды, например `exit 42`?
  - О: Да, вы можете договориться внутри своей команды, что `42` - это, например, "ошибка сети", а `43` - "ошибка доступа".
