# Продвинутый Git: внутреннее устройство и хардкорные техники

## План воркшопа

1. Внутреннее устройство: Объекты, хеши и папка .git.
2. Жизненный цикл файла: Три состояния и магия индекса.
3. Коммиты как искусство: Атомарность и интерактивный add.
4. Ветвление под капотом: Почему ветка - это просто текстовый файл.
5. Слияние миров: Merge против Rebase (разбор на атомы).
6. Контекст и хранение: Продвинутый Stash и Cherry-pick.
7. Машина времени: Reset во всех проявлениях и спасительный Reflog.
8. Хирургия истории: Интерактивный Rebase (squash, reword, drop).
9. Автоматизация: Git Hooks для ленивых и продуктивных.
10. Параллельные миры: Git Worktrees для работы на нескольких фронтах.

## Блок 1: Внутреннее устройство (Интроспекция)

### Текст для выступления

Коллеги, давайте начнем с фундамента. Мы все привыкли к командам, но мало кто заглядывает под капот. Многие думают, что Git хранит дельты (разницу между строчками кода). На самом деле, **Git - это Content-Addressable Storage** (хранилище, адресуемое по контенту). Проще говоря - гигантская хеш-таблица.

Представьте, что весь ваш проект - это набор объектов в папке .git/objects. Там есть три основных типа "существ":

1. **Blobs (Binary Large Objects)**: Это просто содержимое ваших файлов. Git не волнует имя файла, ему важен только контент. Если у вас 10 одинаковых картинок в разных папках, Git сохранит только один Blob.
2. **Trees:** Это "слепки" ваших папок. Дерево знает имена файлов и указывает на конкретные Blobs или другие Trees.
3. **Commits:** Это конверт. В нем лежит ссылка на корневое "Дерево" (весь проект в данный момент), автор, дата и - самое важное - ссылка на родительский коммит.

Всё это связывается через SHA-1 хеши. Хеш - это уникальный ID контента. Если в файле изменится хотя бы один пробел, его хеш станет другим, и Git создаст новый объект. Именно поэтому Git гарантирует целостность: невозможно подменить код в истории, не изменив все последующие хеши."

### Живое демо

1. Создаем пустой репозиторий и смотрим внутрь:

   ```shell
   mkdir git-internal-test && cd git-internal-test
   git init
   ls -F .git/objects # Покажет только папки info и pack (пусто)
   ```

   - **`pack`:** Это папка для оптимизации. Когда объектов становится слишком много (или когда ты делаешь `git gc` или `git push`), Git упаковывает кучу маленьких файлов-объектов в один большой `.pack` файл с индексами. Это экономит место и ускоряет работу по сети.
   - **`info`:** Содержит метаданные о пакетах и дополнительные настройки репозитория (например, файл `attributes`).

2. Создаем файл и смотрим, как рождается Blob:

   ```shell
   echo "Hello Git" > test.txt
   git add test.txt
   # Теперь проверяем, что появилось в базе
   find .git/objects -type f
   ```

   Появился файл в папке `.git/objects/af/....`. Git взял содержимое "Hello Git", захэшировал его и сохранил. Мы еще даже не сделали коммит!

3. Читаем объект из базы Git: Поскольку объекты сжаты zlib, мы не можем прочитать их через cat. Используем встроенную "открывашку" Git.

   ```shell
   # Замените 'af...' на тот хеш, который выдал find
   git cat-file -t af123...  # Покажет тип: blob
   git cat-file -p af123...  # Покажет содержимое: Hello Git
   ```

4. Создаем коммит и находим дерево:

   ```shell
   git commit -m "Initial commit"
   git log --pretty=raw
   ```

   > Посмотрите на вывод pretty=raw. Вы видите хеш коммита, а внутри него - ссылку на tree. Давайте заглянем в это дерево.

5. Разбираем дерево:

   ```shell
   # Берем хеш дерева из предыдущей команды
   git cat-file -p [tree_hash]
   ```

   > Результат будет примерно таким: 100644 blob af123... test.txt

   **Коммит - это просто указатель на дерево, а дерево - список файлов со ссылками на их содержимое"**

### Вывод

- Git ничего не удаляет сразу (если вы сделали add, файл уже в базе).
- История неизменяема, потому что она завязана на хеши.
- Git очень экономен: одинаковое содержимое = один и тот же объект в базе, независимо от количества копий в проекте.

## Блок 2: Три состояния и Индекс

### Текст для выступления

Коллеги, теперь, когда мы знаем, что **Git** - это база объектов, давайте разберем, как файлы туда попадают. В большинстве систем контроля версий есть только два состояния: "мой компьютер" и "репозиторий". В **Git** их три, и между ними находится `Сцена` или `Index`.

Представьте, что вы фотограф.

1. **Working Directory (Рабочая директория):** Это ваша фотостудия. Здесь творится хаос, стоят декорации, ходят модели. Это файлы на вашем диске.
2. **Staging Area (Index / Сцена):** Это то, что попадает в объектив камеры. Вы не фотографируете всю студию целиком. Вы выбираете конкретные объекты, расставляете их и только тогда нажимаете на кнопку. **Index** - это подготовленный кадр.
3. **Repository (HEAD):** Это уже проявленный снимок в вашем альбоме (истории коммитов).

Зачем нужен этот промежуточный Index? Вы могли изменить 10 файлов, но для логики проекта важно разделить их на два разных коммита: например, "рефакторинг" и "новая фича". С помощью Индекса вы можете собрать коммит по крупицам, даже если в рабочей директории у вас "грязный" код.

### Живое демо

1. Подготовка "грязного" состояния:

   ```shell
   echo "Feature code" >> test.txt
   echo "Temporary logs" > logs.log
   # Посмотрим статус
   git status
   ```

   > Git видит изменения в `test.txt` (Modified) и новый файл `logs.log` (Untracked). Сейчас они только в нашей 'студии' (Working Directory)

2. Разница между `diff` и `diff --cached` (Важнейший момент):

   ```shell
   git diff
   ```

   > Видите? git diff показывает разницу между **диском** и **индексом**. Сейчас индекс пуст (в нем старая версия), поэтому мы видим изменения

   ```shell
   git add test.txt
   git diff # Теперь пусто!
   git diff --cached # А вот здесь изменения появились
   ```

   > Это ловушка, в которую попадают многие. `git diff` больше ничего не показывает, потому что в индексе и на диске файл теперь одинаковый. Чтобы увидеть, что вы подготовили к коммиту, всегда используйте флаг `--cached` (или `--staged`)

3. Магия частичного индексирования (`Hunks`): Добавим в `test.txt` еще пару строк в разных частях файла.

   ```shell
   git add -p test.txt
   ```

   _Действие:_ В терминале откроется интерактивное меню. Комментарий: "Смотрите, Git спрашивает: "Stage this hunk? [y,n,q,a,d,j,J,g,/,e,?]". Я могу сказать `y` (да) для верхней части файла и `n` (нет) для нижней. В итоге: на диске у меня файл с двумя изменениями, а в индекс ушло только одно. Я только что создал идеальный коммит, оставив мусор за бортом".

4. Как выкинуть файл со "Сцены" (Unstaging):

   ```shell
   git reset HEAD test.txt
   ```

   > Если вы по ошибке добавили файл в индекс (`git add .`), не нужно удалять его с диска. Команда `reset` просто "выводит его со сцены" обратно в рабочую директорию. Снимок в альбоме при этом не меняется

### Вывод

- **Index** - это ваш черновик. Пока вы не сделали `commit`, вы можете менять состав 'кадра' сколько угодно.
- **git add** - это не просто 'регистрация файла', это копирование его текущего состояния в Index (создание блоба).
- Если вы изменили файл после того как сделали `git add`, эти новые изменения в коммит не попадут, пока вы не сделаете `add` еще раз.

## Блок 3: Коммиты как искусство (Атомарность и интерактивность)

### Текст для выступления

Коллеги, мы разобрались с Индексом. Теперь главный вопрос: что и когда коммитить? Многие грешат "коммитами-поездами": за день поправил стили, пофиксил баг в логике, обновил README и жахнул всё одним коммитом с описанием `fixed stuff`. **Почему это плохо?**

1. Если баг-фикс сломает продакшн, вы не сможете откатить его отдельно от стилей.
2. На Code Review ваш коллега сойдет с ума, пытаясь понять, что к чему относится.

Идеальный подход - **Атомарные коммиты**. Один коммит = одно минимальное логическое изменение. Представьте коммит как транзакцию в базе данных: он либо должен полностью сработать и оставить систему в стабильном состоянии, либо его не должно быть вовсе.

Чтобы достичь этого идеала, даже если вы уже "наговнокодили" всё в одну кучу, у нас есть суперсила - **Интерактивный Add**. Это как хирургический скальпель, который позволяет разрезать ваши изменения на чистые, красивые кусочки.

### Живое демо

Для этого демо нам понадобится файл, в котором смешаны разные типы изменений.

1. **Готовим "грязный" файл:**

   ```shell
   # 1. Создаем файл с базовым кодом ДО начала демо
   cat > app.js << 'EOF'
   function main() {
     console.log("App started");

     // TODO: добавить логику

     return null;
   }
   EOF

   # 2. Коммитим базовую версию
   git add app.js
   git commit -m "init: add base app structure"

   # 3. Добавляем наши изменения
   echo "  // Новая фича" >> app.js
   echo "  const result = calculate();" >> app.js
   echo "" >> app.js
   echo "  // Дебаг вывод" >> app.js
   echo "  console.log(\"Result:\", result);" >> app.js

   # 4. Добавляем еще больше изменений
   echo "" >> app.js
   echo "// FEATURE: New auth logic" >> app.js
   echo "" >> app.js
   echo "function calculate() {" >> app.js
   echo "  return 42;" >> app.js
   echo "}" >> app.js
   echo "" >> app.js
   echo "// DEBUG: Temporary logging" >> app.js
   echo "console.log('Debug info');" >> app.js

   git add -p app.js
   ```

2. **Запускаем магию (`git add -p`):**

   ```shell
   git add -p app.js
   ```

   _Действие:_ На экране появится первый "кусок" (`hunk`) кода.
   _Комментарий:_ "Смотрите, Git нашел изменения. Он спрашивает: закинуть этот кусок на сцену?
   - Если нажать `y` (yes) - этот кусок пойдет в коммит.
   - Если `n` (no) - он останется на диске, но не попадет в коммит.
   - А если кусок слишком большой и в нем смешаны фича и лог? Нажимаем `s` (split)!"

3. **Дробим изменения (Split):**
   _Действие:_ Нажми `s`. Git разделит один большой кусок на два маленьких. Комментарий: "Теперь я нажимаю y на первом куске (фича) и n на втором (дебаг). В итоге на диске у меня остался 'грязный' файл, но в индексе - только чистая фича".

4. Проверяем результат:

   ```shell
   git status # Видим, что файл одновременно и в staged, и в unstaged!
   git diff --cached # Показывает только фичу
   git commit -m "feat: add auth logic"
   ```

5. Что делать с оставшимся мусором?

```shell
git diff # Показывает оставшийся дебаг-лог

# Если он не нужен, мы его просто удаляем одной командой:
git checkout app.js
```

> Мы только что совершили магию: из кучи грязного кода вычленили полезный коммит, а мусор стерли, даже не открывая редактор

### Выводы

- **Коммит должен проходить тесты.** Не коммитьте сломанный код, который не собирается.
- **Используйте префиксы (Conventional Commits):** feat:, fix:, refactor:, docs:. Это делает историю читаемой даже без глубокого вникания в код.
- **Add -p - ваш лучший друг**. Это способ делать ревью самого себя перед тем, как отправить код коллегам.

## Блок 4: Ветвление под капотом (Lightweight Branches)

### Текст для выступления

Коллеги, давайте раз и навсегда разберемся, что такое `ветка`. В других системах контроля версий создание ветки - это создание копии всех файлов. В Git это не так.

Помните, мы говорили, что коммит имеет уникальный хеш? Так вот, **ветка - это просто именованный указатель на этот хеш**. Это - текстовый файл, в котором записано 40 символов ID коммита. Всё создание ветки не занимает места и происходит мгновенно, потому что Git просто создает новый текстовый файлик.

А что такое **HEAD**? Это - `указатель на указатель`. Он говорит Git: "Я сейчас нахожусь вот на этой ветке". Когда вы делаете новый коммит, ветка (указатель) просто передвигается вперед на новый хеш, а HEAD следует за ней.

Если вы понимаете, что ветки - это просто ярлыки, вам становится не страшно их удалять, переименовывать или переключаться между ними сотни раз в день.

### Живое демо

1. Найдем, где живут ветки:

   ```shell
   # Идем в святая святых
   ls -F .git/refs/heads/
   ```

   Комментарий: "Смотрите, здесь лежат файлы с названиями ваших веток: `main`, `develop` и т.д. Давайте заглянем в `main`.

2. Читаем содержимое ветки:

   ```shell
   cat .git/refs/heads/main
   ```

   Результат: Вы увидите длинную строку типа `e1f2a3...`
   _Комментарий:_ "Видите? Никакого кода. Просто адрес последнего коммита. Ветка - это просто закладка в книге".

3. Магия создания ветки вручную (без git branch):

   ```shell
   # Мы можем создать ветку, просто создав файл!
   echo "e1f2a3..." > .git/refs/heads/hack-the-system
   git branch # Опа! Ветка появилась в списке
   ```

4. Разбираем HEAD:

   ```shell
   cat .git/HEAD
   ```

   Результат: `ref: refs/heads/main`
   _Комментарий:_ "HEAD говорит Git: 'Смотри на файл main'. Если мы переключимся на другую ветку, содержимое этого файла изменится".

5. Состояние Detached HEAD (Эксперимент):

   ```shell
   # Переключимся не на ветку, а прямо на хеш коммита
   git checkout [hash_вашего_коммита]
   cat .git/HEAD
   ```

   _Результат:_ Теперь в HEAD лежит сам хеш, а не ссылка на ветку.
   _Комментарий:_ "Это и есть Detached HEAD. Git предупреждает: "Вы ни на какой ветке!". Если вы сделаете коммит сейчас, он будет "сиротой". Чтобы его спасти, нужно просто создать ветку командой `git checkout -b <new-branch-name>`, и этот хеш станет её вершиной".

### Выводы

- **Ветки дешевые.** Не бойтесь создавать их для каждой мелкой задачи.
- **Удаление ветки - это не удаление кода**. Это просто удаление 'ярлыка'. Сам код (объекты) остается в базе, пока не придет Garbage Collector (но об этом позже).
- **HEAD - это ваш палец на строке.** Он указывает, где вы находитесь прямо сейчас.

### Подсказка

```shell
git log --graph
git log --graph --oneline --all
```

Покажи этот график. Объясни, что кружочки - это реальные объекты, а надписи (main, head) - это просто текстовые метки, которые "плавают" над этими кружочками.

## Блок 5: Merge vs Rebase

### Текст для выступления

Итак, у нас есть две ветки, которые разошлись в стороны. Нам нужно собрать код воедино. У Git есть два фундаментально разных способа это сделать.

1. **Merge (Слияние):** Это "дипломатичный" подход. Git берет две ветки, находит их общего предка и создает специальный **Merge Commit**.
   - **Плюс:** Это честная история. Мы видим, когда ветка началась и когда закончилась.
   - **Минус:** Если в команде 20 человек, ваш граф превращается в железнодорожные пути или спагетти, в которых невозможно ничего найти.

2. **Rebase (Перебазирование):** Это "переписывание истории". Представьте, что вы начали делать фичу вчера. За ночь в `main` закинули 10 новых коммитов. Вместо того чтобы делать мерж, вы говорите Git: "Возьми мои коммиты, временно отложи их в сторону, обнови мою ветку до последнего состояния `main`, а потом приклей мои коммиты сверху".

- **Плюс:** Идеально ровная, линейная история. Легко читать, легко делать `bisect`.
- **Минус:** Вы меняете хеши своих коммитов. Они выглядят так же, но технически это новые объекты.

### Живое демо

1. Подготовка конфликта:

   ```shell
   # Создаем ветку и меняем файл
   git checkout -b feature-branch
   # Сделаем `return 5`;
   git commit -am "feat: add feature"

   # Возвращаемся в main и меняем ту же строку
   git checkout main
   # Поменяем значение `return 3`;
   git commit -am "fix: update main"
   ```

2. Демонстрация Merge:

   ```shell
   git merge feature-branch
   # Git откроет редактор для сообщения коммита. Сохраняем.
   git log --graph --oneline
   ```

   Смотрите на график. Появилась "петля". Это и есть Merge Commit. У него два родителя. Мы сохранили контекст того, что работа велась параллельно.

3. Демонстрация Rebase (откат и переделка):

   ```shell
   # Откатим мерж для чистоты эксперимента
   git reset --hard HEAD~1

   git checkout feature-branch
   git rebase main
   ```

   _Действие_: Скорее всего, возникнет конфликт.
   _Комментарий_: "Остановка! При ребейзе конфликты решаются не один раз в конце, а для каждого коммита по очереди. Исправляем файл, делаем `git add app.js` и `git rebase --continue`.

4. Финальный результат:

   ```shell
   git log --graph --oneline --all
   ```

   _Комментарий:_ Ветка `feature-branch` теперь растет прямо из кончика `main`. Никаких петель. История выглядит так, будто я написал этот код только что на самой свежей версии проекта.

### Выводы

- **Merge** - для сохранения истории (например, вливание Feature в Develop).
- _Rebase_ - для поддержания чистоты (подтягивание свежего Master в свою локальную ветку).
- **Конфликты при ребейзе** - это нормально, Git просто перепроверяет каждый ваш шаг.

### Интерактив

1. **Вопрос на засыпку:** Спроси: "Как вы думаете, что легче откатить (revert) - один мерж-коммит или 10 отребейженных коммитов?".
   _(Ответ: один мёрж-коммит откатывает всю фичу сразу, что иногда удобнее в экстренных ситуациях)._

## Блок 6: Контекст и хранение (Stash и Cherry-pick)

### Введение

Этот блок посвящен мобильности разработчика. Мы часто оказываемся в ситуации "переключения контекста": когда работа не закончена, но нужно срочно перепрыгнуть на другую задачу, или когда нужно точечно забрать исправление из чужой ветки.

### Текст для выступления

Коллеги, признайтесь, кто из вас использует `git stash` как "черную дыру"? Скинули туда изменения месяц назад и забыли. Сегодня мы научимся использовать его как осознанный буфер.

**Stash** - это временное хранилище. Представьте, что это ваш рабочий стол. Прилетает срочный баг-фикс - вы сгребаете всё, над чем работали, в ящик стола (stash), чините баг, а потом достаете всё обратно. Но важно делать это аккуратно, чтобы ящик не превратился в свалку.

**Cherry-pick** - это операция "выборочной кражи". Бывает так, что ваш коллега в другой ветке пофиксил баг или написал полезную утилиту, которая нужна вам прямо сейчас. Вам не нужна вся его огромная ветка с кучей лишнего кода - вам нужен только один конкретный коммит. Cherry-pick позволяет "отщипнуть" его и приклеить к вашей истории".

### Живое демо

1. **Продвинутый Stash (не просто `save`):** _Начни что-то писать в файле, но не коммить._

   ```shell
   echo "// Important but unfinished work" >> app.js
   # Вместо обычного stash, дадим ему имя
   git stash save "Work on Auth-module"
   # Посмотрим список
   git stash list
   ```

   _Комментарий:_ "Всегда давайте стэшам имена. Через неделю вы скажете себе спасибо. Теперь ваш `working directory` чист, вы можете переключать ветки.

2. **Возврат из Stash (разница между `pop` и `apply`):**

   ```shell
   # Если вы хотите вернуть изменения и УДАЛИТЬ их из списка:
   git stash pop
   # Если вы хотите применить изменения в одну ветку, но оставить их в stash,
   # чтобы применить еще куда-то:
   git stash apply stash@{0}
   ```

3. **Создание ветки прямо из Stash (Киллер-фича):** _Комментарий:_ "Бывает, что вы достали код из стэша, а он конфликтует с текущей веткой. Есть команда, которая создает новую ветку прямо из вашего сохранения":

   ```shell
   git stash branch feature-from-stash
   ```

4. **Cherry-pick: Крадем коммит:** Создадим параллельную реальность:

```shell
git checkout -b colleagues-branch
echo "// Useful Helper Function" >> utils.js
git commit -am "feat: add useful helper"
# Запоминаем ХЕШ этого коммита

# Возвращаемся в свою ветку
git checkout main
# Нам нужен только этот хелпер!
git cherry-pick [хеш_коммита]
```

_Комментарий:_ "Git просто взял изменения из того коммита и создал точно такой же у нас в ветке. Обратите внимание: хеш у него будет другой, но содержание - то же самое".

### Выводы

- **Stash - это не замена коммитам.** Если работа закончена на 80% - лучше сделать временный коммит (WIP), чем хранить это в стэше.
- **Cherry-pick - это крайняя мера.** Если вам постоянно приходится "черрипикать" друг у друга код, значит, у вас проблемы с архитектурой или делением на ветки.
- Избегайте конфликтов в Cherry-pick: лучше забирать коммиты, которые затрагивают разные файлы.

### Подсказка

1. **Лайфхак:** Покажи команду `git stash -u`. Флаг `-u` (untracked) закидывает в стэше даже новые файлы, которые еще не под контролем Git. Без этого флага обычный stash их проигнорирует.
2. **Предупреждение:** Расскажи, что при Cherry-pick можно забрать сразу диапазон коммитов: `git cherry-pick A..B`.

## Блок 7: Машина времени (Reset и Reflog)

### Текст для выступления

Коллеги, поднимите руки те, кто хоть раз в панике гуглил "как отменить последний коммит" или "я удалил ветку, как её вернуть". Сегодня вы перестанете этого бояться.

У нас есть два главных инструмента для путешествий во времени.

1. **Git Reset:** Это способ переместить указатель ветки назад. У него есть три режима, и важно понимать, что каждый из них делает с вашим кодом:
   - `--soft`: "Я передумал насчет коммита". Коммит исчезает, но все правки остаются в Индексе. Идеально, чтобы переписать сообщение или добавить файл.
   - `--mixed` (по умолчанию): "Я передумал насчет коммита и индекса". Правки остаются на диске, но их нужно заново `add`-ить.
   - `--hard`: "Удали всё и верни как было". Опасная штука, стирает всё на диске до состояния коммита.

2. **Git Reflog:** Это ваша "черная дыра" безопасности. Это журнал всех перемещений вашего `HEAD`. Даже если вы удалили ветку или сделали `reset --hard` не туда, Reflog помнит хеш того места, где вы были 5 минут назад. В Git всё, что попало в базу объектов, живет там еще пару недель, пока не придет уборщик (Garbage Collector)".

### Живое демо

1. **Игры с Reset:** Сделаем тестовый коммит:

   ```shell
   echo "// Important feature" >> app.js
   git commit -am "feat: super feature"
   # Ой, забыли добавить еще одну строку!
   ```

   _Действие:_

   ```shell
   git reset --soft HEAD~1
   # Проверяем:
   git status
   ```

   _Комментарий_: "Смотрите, коммита больше нет, но файлы на месте и уже в индексе (зеленые). Дописываем код, делаем `commit --amend` или новый коммит. Мы просто откатили время на шаг назад".

2. **Моделируем катастрофу (Hard Reset):**

   ```shell
   git reset --hard HEAD~1
   # Теперь проект в состоянии "до фичи", файл пуст.
   ```

   _Комментарий:_ "Представьте, что вы случайно удалили работу за весь день. git log вам не поможет - там этого коммита больше нет. На помощь приходит Reflog".

3. Спасение через Reflog:

   ```shell
   git reflog
   ```

   _Действие:_ В терминале появится список действий. Найди строку, где написано `commit: feat: super feature`. Слева будет хеш (например, `abc1234`). Комментарий: "Видите эту строку? Это запись о том, что мы там были. Git не удалил те данные, он просто убрал на них ярлык. Давайте вернемся туда".

   ```shell
   git reset --hard abc1234
   # Проверяем файл:
   cat app.js
   ```

   _Комментарий:_ "Магия! Мы вернули "удаленные" данные из небытия. Пока вы не очистите репозиторий вручную, Reflog - ваш лучший телохранитель".

### Выводы

- **Reset --hard** - это не конец света, если вы знаете про Reflog.
- Если вы запутались в ребейзе или мёрже - всегда можно посмотреть `reflog` и вернуться в состояние "до начала проблем".
- **HEAD~1** - это удобный способ сказать "на один коммит назад от текущего".

### Подсказка

- **Акцент на безопасности:** Скажи: "Главное правило спасения - ничего не коммитьте поверх, пока не разберетесь. Сначала найдите хеш в рефлоге".

- **Демонстрация `git checkout`:** Покажи, что можно не делать `reset`, а просто создать новую ветку на старом хеше из рефлога: `git checkout -b rescue-branch abc1234`. Это еще безопаснее.

## Блок 8: Хирургия истории (Interactive Rebase)

### Текст для выступления

Коллеги, вспомните свои Pull Requests. Часто они выглядят так:

- `feat: add login page`
- `fix: typo`
- `fix: bug found by tester`
- `debug: try to fix css`
- `revert: debug: try to fix css`

Отправлять такое в общую историю - дурной тон. Это шум, который мешает потом искать ошибки. В идеале ваша работа должна выглядеть как один (или несколько) логически завершенных коммитов.

**Interactive Rebase (`-i`)** - это ваш личный редактор. Он открывает список ваших коммитов в текстовом файле и позволяет вам буквально переписать прошлое: поменять коммиты местами, склеить их, удалить лишние или изменить сообщения.

### Живое демо

1. Подготовка хаоса:

   ```shell
   echo "// Login logic" > auth.js && git add . && git commit -m "feat: login"
   echo "// Typo fixed" >> auth.js && git add . && git commit -m "fix: typo"
   echo "// Another fix" >> auth.js && git add . && git commit -m "fix: another fix"
   echo "// Temporary logs" >> auth.js && git add . && git commit -m "drop me"
   ```

2. Запуск интерактивного режима: Мы хотим поправить последние 4 коммита.

   ```shell
   git rebase -i HEAD~4
   ```

   _Действие:_ Откроется текстовый редактор (Vim или VS Code). В нем будет список коммитов с ключевым словом `pick` перед каждым.

3. Команды "хирурга" (Объяснение на экране):
   - **pick:** Оставить коммит как есть.
   - **reword:** Оставить код, но изменить только сообщение коммита (например, убрать опечатку в заголовке).
   - **squash (s):** Взять этот коммит и "вплавить" его в предыдущий. Сообщения обоих коммитов объединятся.
   - **fixup (f):** То же самое, что squash, но сообщение этого коммита просто выбрасывается (идеально для мелких правок `fix: typo`).
   - **drop (d):** Полностью удалить коммит из истории.

4. Выполнение операции: _В редакторе измените строки:_
   1. Первый оставляем `pick`.
   2. На втором и третьем меняем `pick` на `f` (fixup).
   3. На четвертом (с логами) меняем `pick` на `d` (drop). Сохраните и закройте файл.

5. Проверка результата:

   ```shell
   git log --oneline
   ```

   _Комментарий:_ "Смотрите! Вместо четырех сумбурных коммитов у нас остался один чистый `feat: login`. Весь мусор исчез, все правки склеены. Теперь такой PR не стыдно показывать тимлиду.

### Выводы

- Интерактивный ребейз - это только для локальных веток. Если вы уже запушили коммиты и кто-то на них базируется - ребейз делать нельзя (помните про смену хешей).
- Это лучший способ сделать саморевью: перед пушем пробегитесь по своим коммитам, вдруг там затесался `console.log`.
- Если в процессе что-то пошло не так, просто введите `git rebase --abort`, и вы вернетесь в состояние "до начала операции".

### Подсказка

1. **Лайфхак:** Расскажи про команду `git commit --fixup [hash]`. Если ты нашел опечатку, ты можешь сделать специальный коммит-фиксап, а потом при ребейзе запустить `git rebase -i --autosquash`, и Git сам расставит все `fixup` по своим местам.
2. **Порядок имеет значение:** Покажи, что в списке ребейза можно просто поменять строки местами, и Git изменит порядок коммитов в реальности.

## Блок 9: Git Hooks (Автоматизация для продуктивных)

### Текст для выступления

Коллеги, сколько раз вы видели в мастере коммиты, которые роняют билд? Или забытые `console.log`, или код, который не проходит по стилю (lint)? Мы все люди, мы ошибаемся. Но Git позволяет нам автоматизировать проверки так, чтобы плохой код просто физически не мог попасть в репозиторий.

**Git Hooks (Хуки)** - это скрипты, которые Git запускает автоматически при наступлении определенных событий. Например: перед коммитом, перед пушем или при получении обновлений.

Хуки живут локально в папке `.git/hooks`. Это обычные исполняемые файлы (Bash, Python, Node.js). Самый популярный сценарий - pre-commit. Он запускается сразу после того, как вы ввели `git commit`, но до того, как коммит был фактически создан. Если скрипт возвращает ошибку (exit code 1), Git отменяет коммит.

### Живое демо

1. Где живут хуки:

   ```shell
   ls -F .git/hooks
   ```

   _Комментарий:_ "Видите кучу файлов с расширением `.sample`? Это примеры от создателей Git. Чтобы активировать хук, нужно просто убрать расширение `.sample`".

2. **Создаем свой "запретитель" (Pre-commit hook):** Давайте напишем хук, который не даст закоммитить код, если в нем есть слово "FIXME".

   ```shell
   # Создаем файл хука
   touch .git/hooks/pre-commit
   chmod +x .git/hooks/pre-commit # Делаем его исполняемым
   ```

3. **Пишем логику (Bash-скрипт):** Открой редактор и вставь:

   ```shell
   #!/bin/sh

   # Ищем слово FIXME в файлах, подготовленных к коммиту
   if git diff --cached | grep -q "FIXME"; then
      echo "ОШИБКА: В коде найден FIXME! Сначала исправь, потом коммить."
      exit 1
   fi
   ```

4. Тестируем "ловушку":

   ```shell
   echo "// Important code // FIXME: need to refactor" > app.js
   git add app.js
   git commit -m "feat: some logic"
   ```

5. **Как это сделать в команде (Husky):** _Комментарий:_ "Локальные хуки в папке `.git` не пушатся в репозиторий. Чтобы вся команда работала по одним правилам, в JS-мире используют библиотеку **Husky**. Она выносит хуки в обычные файлы проекта, которые хранятся в Git и синхронизируются у всех". Но в большинстве случаев рекомендую использовать **lefthook**

### Выводы

- **Pre-commit:** Проверяем синтаксис, линтеры, форматирование (Prettier).
- **Prepare-commit-msg:** Автоматически добавляем номер тикета из названия ветки в сообщение коммита.
- **Pre-push:** Запускаем тяжелые тесты, чтобы не ждать падения CI/CD на сервере.
- Как обойти: Если ну очень надо (например, горящий фикс), можно добавить флаг `--no-verify`, чтобы пропустить хуки. Но пользуйтесь этим крайне осторожно!

### Интерактив

1. **Вопрос в зал:** "Кто тратит время на code review, исправляя чужие отступы или опечатки?". Расскажи, что хуки решают эту проблему раз и навсегда.
2. **Идея для внедрения:** Предложи внедрить хук, который проверяет название веток на соответствие формату `feature/...` или `bugfix/....`

## Блок 10: Git Worktrees (Параллельные миры)

### Текст для выступления

Коллеги, финальный инструмент на сегодня. Представьте классическую ситуацию: вы в самом разгаре написания сложнейшей фичи. У вас изменено 20 файлов, половина кода не компилируется. И тут прилетает Critical Hotfix на продакшене.

Что мы обычно делаем?

1. `git stash` (надеемся, что ничего не забудем).
2. `git checkout main`.
3. Чиним, пушим.
4. `git checkout feature`.
5. `git stash pop` (и ловим конфликты со своим же утренним кодом).

**Git Worktree** позволяет избежать этого ада. Он позволяет иметь несколько рабочих директорий для одного и того же репозитория. Вы просто создаете соседнюю папку, в которой открыта другая ветка того же проекта. Никаких переключений, никаких `stash`. Вы можете просто открыть второе окно IDE и фиксить баг, пока в первом окне крутятся тесты вашей фичи".

### Живое демо

1. Проверяем текущее состояние:

   ```shell
   git branch
   # Допустим, мы на ветке 'feature-auth'
   ```

2. Создаем "параллельный мир" для хотфикса: Мы хотим создать папку `hotfix-dir` и сразу открыть в ней ветку `main`.

   ```shell
   git worktree add ../hotfix-dir main
   ```

   _Комментарий:_ "Смотрите, что произошло. Git не скопировал весь репозиторий (папка `.git` осталась одна). Он просто создал 'отросток' в соседней папке. Теперь у нас две рабочие копии кода".

3. Работаем в двух местах одновременно:

   ```shell
   ls ..
   # Вы увидите: project-folder и hotfix-dir
   cd ../hotfix-dir
   # Здесь мы в ветке main. Делаем правки, коммитим, пушим.
   ```

   _Комментарий:_ "В это время в основной папке project-folder всё осталось нетронутым. Ваша фича на месте, файлы не менялись. Вы даже можете запустить сервер в обеих папках на разных портах".

4. Список активных миров:

   ```shell
   git worktree list
   ```

   _Комментарий:_ "Git показывает все пути, где сейчас 'развернуты' ваши ветки".

5. Уборка:

   ```shell
   # Когда баг исправлен и папка больше не нужна:
   cd ../git-internal-test
   git worktree remove ../hotfix-dir
   ```

_Комментарий:_ "Папка удалена, а вы просто продолжаете писать фичу. Чисто, элегантно, без лишних движений".

### Вывод

- **Одна база - много папок.** Вы экономите место на диске и время на переключении.
- **Независимость.** Ошибки компиляции в одной ветке никак не мешают вам работать в другой.
- **Ограничение:** Git не позволит вам открыть одну и ту же ветку в двух разных Worktree одновременно (чтобы не возникло коллизий в истории).

### Подсказка

1. **Сценарий для профи:** "Представьте, что вам нужно сравнить работу приложения на двух разных ветках. Раньше вы бы переключались туда-сюда. С Worktree вы запускаете два инстанса приложения одновременно и сравниваете в браузере".
2. **Нюанс с путями:** Напомни, что папку с Worktree лучше создавать вне текущей папки проекта (на уровень выше), чтобы одна не попала в другую как `untracked file`.
